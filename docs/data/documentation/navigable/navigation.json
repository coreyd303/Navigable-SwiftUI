{"metadata":{"modules":[{"name":"Navigable"}],"roleHeading":"Article","title":"‚õµ Navigable","role":"article"},"primaryContentSections":[{"content":[{"anchor":"Introduction","level":2,"type":"heading","text":"Introduction"},{"inlineContent":[{"code":"Navigable","type":"codeVoice"},{"text":" is a lightweight, protocol-driven architecture designed to make navigation in SwiftUI apps modular, scalable, and testable. It abstracts the mechanics of SwiftUI‚Äôs navigation stack, sheets, and full-screen covers into a declarative, composable system that is easy to adopt and extend across your application.","type":"text"},{"text":" ","type":"text"},{"text":"Inspired by the limitations of tightly coupled navigation logic, ","type":"text"},{"code":"Navigable","type":"codeVoice"},{"text":" provides a clear contract for defining view destinations in a centralized way‚Äîmoving navigation responsibility from views into view models or coordinators, where it can be reasoned about, tested, and reused more effectively.","type":"text"}],"type":"paragraph"},{"anchor":"Purpose","level":2,"type":"heading","text":"Purpose"},{"inlineContent":[{"type":"text","text":"The goal of "},{"code":"Navigable","type":"codeVoice"},{"type":"text","text":" is to "},{"type":"strong","inlineContent":[{"text":"unify and simplify navigation","type":"text"}]},{"type":"text","text":" by introducing a consistent interface and separation of concerns. Instead of scattering "},{"code":"NavigationLink","type":"codeVoice"},{"type":"text","text":", "},{"code":".sheet","type":"codeVoice"},{"type":"text","text":", or "},{"code":".fullScreenCover","type":"codeVoice"},{"type":"text","text":" throughout your view hierarchy, "},{"code":"Navigable","type":"codeVoice"},{"type":"text","text":" provides a centralized model to:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Define all possible navigation paths (","type":"text"},{"code":"Route","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Sheet","type":"codeVoice"},{"text":", ","type":"text"},{"code":"FullScreenCover","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Handle deep links or state restoration by mapping structured routes to destinations"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Decouple navigation logic from view rendering","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Promote reuse and consistency across the app"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Benefits","level":2,"type":"heading","text":"Benefits"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"‚úÖ "},{"inlineContent":[{"text":"Declarative & Composable","type":"text"}],"type":"strong"},{"type":"text","text":": Navigation state lives in a "},{"type":"codeVoice","code":"@Bindable"},{"type":"text","text":" model and is driven through SwiftUI‚Äôs view hierarchy using a view modifier."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"‚úÖ ","type":"text"},{"inlineContent":[{"text":"Stateful","type":"text"}],"type":"strong"},{"text":": Prevent illegal navigation states by unifying ","type":"text"},{"code":"NavigationState","type":"codeVoice"},{"text":" under one source of truth.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"‚úÖ ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Deep Link Ready"}]},{"text":": Routes can be constructed programmatically and matched to URLs or external triggers easily.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"‚úÖ ","type":"text"},{"inlineContent":[{"text":"Centralized Navigation Logic","type":"text"}],"type":"strong"},{"text":": All destination presentation logic is implemented in the conforming ","type":"text"},{"code":"Navigable","type":"codeVoice"},{"text":" type, making the behavior explicit and testable.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"‚úÖ "},{"type":"strong","inlineContent":[{"text":"No View Coupling","type":"text"}]},{"type":"text","text":": Views no longer own or manage navigation directly‚Äîview models (or coordinators) do."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"‚úÖ "},{"inlineContent":[{"text":"Flexible Presentation","type":"text"}],"type":"strong"},{"type":"text","text":": Supports "},{"type":"codeVoice","code":"navigationDestination"},{"type":"text","text":", "},{"type":"codeVoice","code":".sheet"},{"type":"text","text":", and "},{"type":"codeVoice","code":".fullScreenCover"},{"type":"text","text":" from the same unified model."}]}]},{"content":[{"inlineContent":[{"text":"‚úÖ ","type":"text"},{"type":"strong","inlineContent":[{"text":"Macro-Compatible","type":"text"}]},{"text":": Designed to eventually support macro-based synthesis for reducing boilerplate.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Implementation-and-Code-Example","level":2,"type":"heading","text":"Implementation and Code Example"},{"inlineContent":[{"type":"codeVoice","code":"Navigable"},{"type":"text","text":" was designed to make implementation as easy and simple as possible. Subscribing to "},{"type":"codeVoice","code":"Navigable"},{"type":"text","text":" or "},{"type":"codeVoice","code":"NavigableView"},{"type":"text","text":" provides a synthesized super power for easy stateful navigation. It should be noted that the recommended way to implement "},{"type":"codeVoice","code":"Navigable"},{"type":"text","text":" is using a "},{"type":"codeVoice","code":"Coordinator"},{"type":"text","text":", "},{"type":"codeVoice","code":"ViewModel"},{"type":"text","text":", or other data"},{"type":"text","text":" "},{"type":"text","text":"provider object in conjunction with a view."}],"type":"paragraph"},{"type":"thematicBreak"},{"anchor":"%F0%9F%92%A1-This-example-demonstrates-how-to-use-applyNavigation-with-either-ViewModel-that-conform-to-Navigable-or-a-view-that-conforms-to-NavigableView","level":3,"type":"heading","text":"üí° This example demonstrates how to use `applyNavigation` with either `ViewModel` that conform to `Navigable`, or a view that conforms to `NavigableView`."},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To see this in action, check out the demo app in the "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/coreyd303\/Navigable-SwiftUI\/tree\/main\/Example\/NavigableSampleApp"},{"type":"text","text":" folder!"}]}]}],"type":"unorderedList"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Run the Example:"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Clone this repository"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Open "},{"type":"codeVoice","code":"Example\/NavigableSampleApp\/NavigableSampleApp.xcodeproj"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Build and run to see Navigable in action!","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"type":"text","text":"In "},{"type":"codeVoice","code":"Views"},{"type":"text","text":" that leverage a "},{"type":"codeVoice","code":"ViewModel"},{"type":"text","text":":"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"code":"@State var viewModel","type":"codeVoice"},{"text":" drives the navigation state.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"isRootNavigator: true"},{"text":" ensures the view manages its own ","type":"text"},{"type":"codeVoice","code":"NavigationStack"},{"text":".","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Prevents nested "},{"type":"codeVoice","code":"NavigationStack"}],"type":"strong"},{"type":"text","text":", which can cause unexpected dismissal or broken back navigation."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: you can only have one root navigator in any workflow, having more than one will result in unexpected behaviors."}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"code":"destinationBuilder","type":"codeVoice"},{"text":" and other navigation methods are delegated to the ","type":"text"},{"code":"ViewModel","type":"codeVoice"},{"text":", encapsulating navigation logic.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"level":3,"text":"‚ú≥Ô∏è A set of syntesized methods are provided to any object or view that conforms to `Navigable` or `NavigableView`. It is recommended that you use these methods instead of directly setting the value of `NavigationState`. These methods ensure that the navigation stack is unified and correctly managed as your navigation changes.","type":"heading","anchor":"%E2%9C%B3%EF%B8%8F-A-set-of-syntesized-methods-are-provided-to-any-object-or-view-that-conforms-to-Navigable-or-NavigableView-It-is-recommended-that-you-use-these-methods-instead-of-directly-setting-the-value-of-NavigationState-These-methods-ensure-that-the-navigation-stack-is-unified-and-correctly-managed-as-your-navigation-changes"},{"items":[{"content":[{"inlineContent":[{"code":"push(_ route: any Routable)","type":"codeVoice"},{"type":"text","text":" : push a route onto the stack"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"push(_ routes: [any Routable])","type":"codeVoice"},{"text":" : push multiple routes onto the stack","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"pop()"},{"type":"text","text":" : pop the last route from the stack"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"popTo(index: Int)"},{"type":"text","text":" : pop a specific route from the stack"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"popToRoot()"},{"text":" : pop to the bottom of the stack","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"swap(_ route: any Routable)","type":"codeVoice"},{"type":"text","text":" : replace the last route on the stack with a new route"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"present(_ fullScreenCover: any Coverable)"},{"type":"text","text":" : present a full screen cover"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"present(_ sheet: any Sheetable)"},{"type":"text","text":" : present a sheet"}]}]},{"content":[{"inlineContent":[{"code":"display(_ alert: AnyAlert)","type":"codeVoice"},{"type":"text","text":" : display an alert"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"display(_ dialog: AnyConfirmationDialog)","type":"codeVoice"},{"text":" : display a confirmation dialog","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"enqueue(navigation action: after delay:)"},{"type":"text","text":" :"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When changing presentation or display on a "},{"type":"codeVoice","code":"View"},{"type":"text","text":", ie: swapping from one Sheet to another, "},{"type":"codeVoice","code":"SwiftUI"},{"type":"text","text":" can find itself in a bit of a "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" state conflict due to the async nature of "},{"type":"codeVoice","code":"View"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"enqueue","type":"codeVoice"},{"type":"text","text":" provides an elegant way to handle this, acheiving a smooth transion from one presentation or display to another."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"enqueue"},{"text":" can be use with any ","type":"text"},{"type":"codeVoice","code":"NavigationState"},{"text":" but will result in a complete swap of the state, this is relevent when you have a preexisting stack. Take note: ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"enqueue will "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" the state before replacing"}]},{"text":".","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"code":"dismissPresentationOrDisplay()","type":"codeVoice"},{"text":" : dismiss a presentation or a display","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"thematicBreak"},{"level":3,"text":"‚ú¥Ô∏è A helper method is provided to facilitate unifying all `View` types into `AnyView`.","type":"heading","anchor":"%E2%9C%B4%EF%B8%8F-A-helper-method-is-provided-to-facilitate-unifying-all-View-types-into-AnyView"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":".eraseToAnyView()","type":"codeVoice"},{"type":"text","text":" is a synthesized method that is provided to easily and uniformly implement wrapping all custom "},{"code":"View","type":"codeVoice"},{"type":"text","text":" types into the type erased "},{"code":"AnyView","type":"codeVoice"},{"type":"text","text":" type."}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":3,"text":"‚ú® Using `EmptyView()` as a fallback type is preferred.","anchor":"%E2%9C%A8-Using-EmptyView-as-a-fallback-type-is-preferred"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"It is recommended that you use ","type":"text"},{"type":"codeVoice","code":"EmptyView()"},{"text":" as your fallback type when implementing ","type":"text"},{"type":"codeVoice","code":"Navigable"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This choice is intentional and preferred over other options such as throwing or optional returns to make implementation as seamless as possible"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using "},{"type":"codeVoice","code":"EmptyView()"},{"type":"text","text":" provides a very clear indication of issues that can be seen during UI testing or regressing, and clearly denotes develeoper errors as "},{"type":"codeVoice","code":"EmptyView()"},{"type":"text","text":" is an unexpected result of any navigation action"}]}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"type":"heading","level":3,"text":"üí† Syntesized methods are provided to manage all forms of navigation","anchor":"%F0%9F%92%A0-Syntesized-methods-are-provided-to-manage-all-forms-of-navigation"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Navigable provides a set of synthesized methods to manage all possible navigation actions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Failing default implementations are provided on both ","type":"text"},{"code":"Navigable","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"NavigableView","type":"codeVoice"},{"text":". This means you only need to implement what you need, and your code will fail fast if you try to perform a navigation type that you have not implemented support for.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"open func destination(for route: any Routable) -> AnyView","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"code":"open func sheetPresentation(for sheet: any Sheetable) -> AnyView","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"open func fullScreenCoverPresentation(for fullScreenCover: any Coverable) -> AnyView"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"open func alert(for alert: AnyAlert) -> AnyAlert","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"open func confirmationDialog(for dialog: AnyConfirmationDialog) -> AnyConfirmationDialog"}]}]}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":3,"text":"üü£ It is recommended to manage dismissal via call back","anchor":"%F0%9F%9F%A3-It-is-recommended-to-manage-dismissal-via-call-back"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"While ","type":"text"},{"code":"SwiftUI","type":"codeVoice"},{"text":"s ","type":"text"},{"code":"@Environment(\\.dismiss)","type":"codeVoice"},{"text":" can be used in conjunction with ","type":"text"},{"code":"Navigable","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"NavigableView","type":"codeVoice"},{"text":" however it is preferrable to manage dismissal using a custom call back","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This unifies all parts of the navigation life cycle, and ensures a fully stateful navigation experience"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This also means that you can test dismissal when using "},{"type":"codeVoice","code":"Navigable"},{"type":"text","text":"!"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Examples of this can be seen throughout the code sample"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"type":"heading","level":3,"text":"üü• `applyNavigation` is the superpower!","anchor":"%F0%9F%9F%A5-applyNavigation-is-the-superpower"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"applyNavigation"},{"type":"text","text":" func is where the magic of "},{"type":"codeVoice","code":"Navigable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"NavigableView"},{"type":"text","text":" comes to life"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"This method passes the stateful "},{"type":"codeVoice","code":"NavigationState"},{"type":"text","text":" through to the "},{"type":"codeVoice","code":"NavigationService"},{"type":"text","text":" and drives all of your navigation needs"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"In order to simplify implementation, synthesized methods are provided on both ","type":"text"},{"code":"Navigable","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"NavigableView","type":"codeVoice"},{"text":". These builder methods do all the heavy lifting for you, and are available on both ","type":"text"},{"code":"Navigable","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"NavigableView","type":"codeVoice"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"destinationBuilder"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"sheetPresentationBuilder"}]}]},{"content":[{"inlineContent":[{"text":"fullScreenCoverPresentationBuilder","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"type":"heading","level":3,"text":"üîÜ Atomic implementations of `Navigable` objects are reuseable","anchor":"%F0%9F%94%86-Atomic-implementations-of-Navigable-objects-are-reuseable"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Keep in mind, that you need to consider preserved state!","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Because ","type":"text"},{"code":"Navigable","type":"codeVoice"},{"text":" applies only to reference types, any existing instance passed in to a child ","type":"text"},{"code":"View","type":"codeVoice"},{"text":" etc. will maintain reference semantics.","type":"text"}]}]}],"type":"unorderedList"}]}]},{"type":"thematicBreak"},{"syntax":"swift","type":"codeListing","code":["\/\/ MARK: Root View","","struct BaseView: View {","    @State var viewModel = BaseViewModel()","","    var body: some View {","        VStack(spacing: 20) {","            Button(\"Push Route\") {","                viewModel.push(Routez.route1) \/\/ ‚ú≥Ô∏è a set of syntesized methods are provided to any object or view that conforms to `Navigable` or `NavigableView`","            }","        }","        .buttonStyle(.primaryV2)","        .applyNavigation( \/\/ üü• `applyNavigation` is the superpower!","            navigationState: $viewModel.navigationState,","            isRootNavigator: true,","            destinationBuilder: viewModel.destinationBuilder","        )","    }","}","","#Preview {","    BaseView()","}"]},{"type":"aside","style":"note","name":"Note","content":[{"type":"heading","level":4,"text":"üí° Each `Navigable` type is defined using an enum. In this case, we are defining routes tied to the root `NavigationStack`.","anchor":"%F0%9F%92%A1-Each-Navigable-type-is-defined-using-an-enum-In-this-case-we-are-defining-routes-tied-to-the-root-NavigationStack"}]},{"type":"codeListing","syntax":"swift","code":["enum Routez: Routable {","    case route1","}","","@Observable","final class BaseViewModel: Navigable {","    override func destination(for route: any Routable) -> AnyView { \/\/ üí† Syntesized methods are provided to manage all forms of navigation","        guard let route = route as? Routez else {","            return EmptyView().eraseToAnyView() ","            \/\/ ‚ú¥Ô∏è A helper method is provided to facilitate unifying all View types into AnyView. ","            \/\/ ‚ú® Using EmptyView as a fallback type is preferred.","        }","","        switch route {","        case .route1:","            return RouteView {","                self.pop() ","                \/\/ ‚ú≥Ô∏è a set of syntesized methods are provided to any object or view that conforms to `Navigable` or `NavigableView`","                \/\/ üü£ It is recommended to manage dismissal via call back","            }","            .eraseToAnyView() \/\/ ‚ú¥Ô∏è A helper method is provided to facilitate unifying all View types into AnyView.","        }","    }","}","","\/\/ MARK: - Route View","","struct RouteView: View {","    @State var viewModel = RouteViewModel()","    let dismissView: () -> Void \/\/ üü£ It is recommended to manage dismissal via call back","","    var body: some View {","        VStack(spacing: 20) {","            Text(\"Route View\")","","            Button(\"Present Sheet\") {","                viewModel.present(Sheetz.sheet1) \/\/ ‚ú≥Ô∏è a set of syntesized methods are provided to any object or view that conforms to `Navigable` or `NavigableView`","            }","","            Button(\"Dismiss Me\") {","                dismissView() \/\/ üü£ It is recommended to manage dismissal via call back","            }","        }","        .buttonStyle(.primaryV2)","        .applyNavigation( \/\/ üü• `applyNavigation` is the superpower!","            navigationState: $viewModel.navigationState,","            isRootNavigator: false,","            sheetPresentationBuilder: viewModel.sheetPresentationBuilder","        )","    }","}"]},{"type":"aside","style":"note","name":"Note","content":[{"text":"üí° Each `Navigable` type is defined using an enum. In this case, we are defining sheets tied to the root `NavigationStack`.","type":"heading","level":4,"anchor":"%F0%9F%92%A1-Each-Navigable-type-is-defined-using-an-enum-In-this-case-we-are-defining-sheets-tied-to-the-root-NavigationStack"}]},{"type":"codeListing","syntax":"swift","code":["enum Sheetz: Sheetable {","    case sheet1","    case sheet2","}","","final class RouteViewModel: Navigable {","    override func sheetPresentation(for sheet: any Sheetable) -> AnyView {","        guard let sheet = sheet as? Sheetz else {","            return EmptyView().eraseToAnyView()","        }","","        switch sheet {","        case .sheet1:","            return SheetView(","                title: \"Sheet View 1\",","                dismissView: {","                    \/\/ ‚ú≥Ô∏è a set of syntesized methods are provided to any object or view that conforms to `Navigable` or `NavigableView`","                    self.enqueue { ","                        self.present(Sheetz.sheet2)","                    }","                }","            )","            .eraseToAnyView()","        case .sheet2:","            return AnotherSheetView(","                dismissAction: {","                    self.dismissPresentationOrDisplay()","                },","                confirmationAction: {","                    \/\/ take some other action based on confirmation...","                    self.dismissPresentationOrDisplay()","                }","            )","            .eraseToAnyView()","        }","    }","}","","\/\/ MARK: Sheet View","","struct SheetView: View {","    @State var viewModel = RouteViewModel() \/\/ üîÜ Atomic implementations of `Navigable` objects are reuseable","    let dismissView: () -> Void","","    var body: some View {","        VStack(spacing: 20) {","            Text(\"Sheet View\")","","            Button(\"Present another sheet\") {","                viewModel.present(Sheetz.sheet2) \/\/ ‚ú≥Ô∏è a set of syntesized methods are provided to any object or view that conforms to `Navigable` or `NavigableView`","            }","","            Button(\"Dismiss Me\") {","                dismissView()","            }","        }","        .buttonStyle(.primaryV2)","        .applyNavigation( \/\/ üü• `applyNavigation` is the superpower!","            navigationState: $viewModel.navigationState,","            isRootNavigator: false,","            sheetPresentationBuilder: viewModel.sheetPresentationBuilder","        )","    }","}"]},{"type":"aside","style":"note","name":"Note","content":[{"type":"heading","anchor":"In-this-case-you-will-see-that-the-View-implements-NavigableView-This-has-tradeoffs-but-with-correct-consideration-can-be-used-appropriatly","level":4,"text":"In this case, you will see that the `View` implements `NavigableView`. This has tradeoffs, but with correct consideration can be used appropriatly."},{"type":"paragraph","inlineContent":[{"text":"This view only requires a confirmation dialog presentation, the business logic behind it is managed through a custom callback.","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ MARK: Another Sheet View","","struct AnotherSheetView: NavigableView {","    @State var navigationState: NavigationState? \/\/ üìå `NavigableView` being a protocol does require that we maintain our own stateful reference","    let dismissView: () -> Void","    let confirmationAction: () -> Void","","    var body: some View {","        VStack(spacing: 20) {","            Text(\"Another Sheet View\")","","            Button(\"Confirm?\") {","                display( \/\/ ‚ú≥Ô∏è a set of syntesized methods are provided to any object or view that conforms to `Navigable` or `NavigableView`","                    confirmationDialog,","                    using: $navigationState","                ) ","            }","        }","        .buttonStyle(.primaryV2)","        .applyNavigation( \/\/ üìå in this case we don't need to leverage any builders","            navigationState: $navigationState,","            isRootNavigator: false","        )","    }","","    private var confirmationDialog: AnyConfirmationDialog {","        AnyConfirmationDialog(","            title: \"Are you sure?\",","            message: \"Just checking!\",","            actions: [","                AnyConfirmationDialog.DialogAction(","                    title: \"Yes!\",","                    action: {","                        confirmationAction()","                    }","                ),","                AnyConfirmationDialog.DialogAction(","                    title: \"No!\",","                    role: .cancel,","                    action: {","                        display(alert, using: $navigationState) \/\/ üìå because `NavigationState` is stateful, we don't have to fear illegal states","                    }","                )","            ]","        )","    }","","    private var alert: AnyAlert {","        AnyAlert(","            style: .system(","                title: \"Boo Hoo\",","                message: \"That's too bad!\",","                primaryButton: .cancel(),","                secondaryButton: nil","            )","        )","    }","}"]}],"kind":"content"}],"kind":"article","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/navigable-swiftui.Navigable\/documentation\/Navigable\/Navigation"},"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"paths":["\/documentation\/navigable\/navigation"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"hierarchy":{"paths":[["doc:\/\/navigable-swiftui.Navigable\/documentation\/Navigable"]]},"references":{"https://github.com/coreyd303/Navigable-SwiftUI/tree/main/Example/NavigableSampleApp":{"url":"https:\/\/github.com\/coreyd303\/Navigable-SwiftUI\/tree\/main\/Example\/NavigableSampleApp","identifier":"https:\/\/github.com\/coreyd303\/Navigable-SwiftUI\/tree\/main\/Example\/NavigableSampleApp","titleInlineContent":[{"type":"codeVoice","code":"Example\/NavigableSampleApp"}],"title":"Example\/NavigableSampleApp","type":"link"},"doc://navigable-swiftui.Navigable/documentation/Navigable":{"title":"Navigable","type":"topic","abstract":[],"url":"\/documentation\/navigable","role":"collection","kind":"symbol","identifier":"doc:\/\/navigable-swiftui.Navigable\/documentation\/Navigable"}}}